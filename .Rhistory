# analyse participant level data
# load the relevant libraries
x<-c("tidyverse","car", "nlme", "lme4", "ez", "dplyr", "ggplot2", "knitr","stringr","nortest","gridExtra","png","R.matlab","lmerTest","simpleboot")
lapply(x, function(x) {if (!require(x, character.only=T)) {install.packages(x);require(x)}})
# clear all
rm(list=ls(all=TRUE))
# which dataset?
dataset2use = 'bigDots'; nSub = 80;
dataset2use = 'CD'; nSub = 17;
filedir = str_c('E:/Monash/', dataset2use, '/data/population/')
figDir  = str_c(filedir, 'fig/R/' )
dir.create(figDir, showWarnings = TRUE)
# load useful functions ---------------------------------------------------
wddir   = str_c('C:/Jochem/repositories/2018_Monash/')
setwd(wddir)
source("summarySE.R")
# a few settings defined in Matlab, goes in the filename that will be loaded
CSD = 0
nChanAlpha = 3
# what is the number of bins etc?
nside           = 1;
nbin            = 5;
bintype         = 'equal';
# which sorting?
bin2use         = 'pupil_lp_baseline_regress_iti_side'
# bin2use         = 'pupil_bp_baseline_regress_iti_side'
# load participant level data
filename = str_c('participant_level_side(',nside ,')_bin(', nbin, ')_', bin2use ,
'_equal_CSD(', CSD, ')_','chAlpha(', nChanAlpha, ')_final' )
data_p_level = read_csv(str_c(filedir, filename,'.csv'))
data_p_level$Subject <- factor(data_p_level$Subject)
data_p_level$Side <- factor(data_p_level$Side)
data_p_level$Bin <- factor(data_p_level$Bin,labels=c("1", "2", "3", "4", "5"))
#  ------------------------------------------------------------------------
## check number of trials in each condition
sum_trials <- summarySE(data_p_level, measurevar="nTrial", groupvars=c("Bin","Side"))
sum_trials <- data.frame(sum_trials)
tt <- ttheme_default(colhead=list(fg_params = list(parse=TRUE)))
tbl <- tableGrob(sum_trials, rows=NULL, theme=tt)
png(str_c(figDir,'nTrials', bin2use, '.png'))
grid.arrange(tbl)
dev.off()
#  ------------------------------------------------------------------------
data_p_level$Bin <- as.numeric(data_p_level$Bin) # for polynomial contrasts to be set
data_p_level <- within(data_p_level, polyBin <- poly(Bin,2)) # define orthogonal polynomial
# our model has a random intercept for each subject (repeated measrures analysis)
model.Intercept     <- lme4::lmer(RT ~ 1 +
(1|Subject),
data = data_p_level, na.action = na.omit, REML=FALSE) # baseline model to compare the effect of bin to.
model.bin       <- update(model.Intercept, .~. + polyBin[, 1]) # test linear polynomial
model.binQ      <- update(model.bin, .~. + polyBin[, 2])# test quadratic polynomial
# model.bin       <- update(model.Intercept, .~. + Bin) # test linear polynomial, not orthogonal!!
# model.binQ      <- update(model.bin, .~. + I(Bin^2))# test linear polynomial, not orthogonal!!
anova(model.Intercept, model.bin, model.binQ) #compare likelihood of models
library(broom)
summary(model.binQ)
kable(tidy(model.binQ),digits = 3)
library(MuMIn)
r.squaredGLMM(model.binQ)
# see https://jonlefcheck.net/2013/03/13/r2-for-linear-mixed-effects-models/ for an explanation of marginal and conditional R2
library(piecewiseSEM)
rsquared(list(model.Intercept,model.binQ))
#
# exclude some variables
all.dependent.variables <- data_p_level %>%
dplyr::select(-one_of("Subject"), -one_of("Side"), -one_of("Bin"), -one_of("polyBin"),
-one_of("nTrial"),
-one_of("pupil_bl_lp"), -one_of("pupil_bl_bp")) %>%
names()
fitlist_lme4 <- lapply(all.dependent.variables, function(i) {
eval(parse(text=
paste0('
model.baseline     <- lme4::lmer(', i, ' ~ (1|Subject), data = data_p_level, na.action = na.omit, REML=FALSE) # baseline model to compare the effect of bin to
model.bin          <- update(model.baseline, .~. + polyBin[, 1]) # test model with Bin, linear
model.binQ         <- update(model.bin, .~. + polyBin[, 2]) # test model with Bin, quadratic
stat <- anova(model.baseline, model.bin,model.binQ)
# model.bin <- as(model.bin,"merModLmerTest") # use the lmerTest package to obtain a p-value for the coefficients
trend <- coef(summary(model.binQ))
fit_Y_L <- predict(model.bin)
mat_fitL <- matrix(NA, nrow =1, ncol = (nSub*nbin))
mat_fitL[as.numeric(names(fit_Y_L))] <-  unname(fit_Y_L)
# mat_fitL <- matrix(mat_fitL, nrow = nSub, byrow = FALSE)
fit_Y_Q <- predict(model.binQ)
mat_fitQ <- matrix(NA, nrow =1, ncol = (nSub*nbin))
mat_fitQ[as.numeric(names(fit_Y_Q))] <-  unname(fit_Y_Q)
# mat_fitQ <- matrix(mat_fitQ, nrow = nSub, byrow = FALSE)
list(stat=stat, trend=trend, fitL=mat_fitL, fitQ=mat_fitQ)
')
))
})
# write the results to a csv file
### lme4 stats
lme_stat <- as.data.frame(sapply(fitlist_lme4, "[[", 1))
colnames(lme_stat) <- all.dependent.variables
lme_stat <- t(lme_stat)
lme_stat <- cbind(rownames(lme_stat), lme_stat)
rownames(lme_stat) <- NULL
colnames(lme_stat)[1] <- c("key")
lme_stat <- as_tibble(lme_stat)
lme_stat$key <- as.character(lme_stat$key)
lme_stat2 <- lme_stat[,1]
lme_stat2$Df_Intercept <- sapply(lme_stat$Df, "[[", 1)
lme_stat2$Df_L <- sapply(lme_stat$Df, "[[", 2)
lme_stat2$Df_Q <- sapply(lme_stat$Df, "[[", 3)
lme_stat2$Chisq_L <- sapply(lme_stat$Chisq, "[[", 2)
lme_stat2$Chisq_Q <- sapply(lme_stat$Chisq, "[[", 3)
lme_stat2$P_L <- sapply(lme_stat$`Pr(>Chisq)`, "[[", 2)
lme_stat2$P_Q <- sapply(lme_stat$`Pr(>Chisq)`, "[[", 3)
### lme4 trends
row2get = c(2,3)
col2get = c(1,2,3)
trendlist_colnames <- names(data.frame(fitlist_lme4[[1]]$trend))
trendlist_rownames <- rownames(data.frame(fitlist_lme4[[1]]$trend))
trendlist_rownames <- rownames(data.frame(fitlist_lme4[[1]]$trend))
trendlist_colnames[which(trendlist_colnames=="Estimate")] <- 'Estimate_Trend'
trendlist_colnames[which(trendlist_colnames=="Std..Error")] <- 'SE_Trend'
trendlist_colnames[which(trendlist_colnames=="t.value")] <- 't_Trend'
trendlist_rownames[which(trendlist_rownames=="(Intercept)")] <- 'Intercept'
trendlist_rownames[which(trendlist_rownames=="polyBin[, 1]")] <- 'BinL'
trendlist_rownames[which(trendlist_rownames=="polyBin[, 2]")] <- 'BinQ'
trends <- as.data.frame(sapply(1:length(fitlist_lme4), function(i) as.numeric(fitlist_lme4[[i]]$trend[row2get,col2get])))
newcolnames <- apply(expand.grid(trendlist_rownames[row2get], trendlist_colnames[col2get]), 1, function(x) paste(x[1], x[2], sep="_"))
colnames(trends) <- all.dependent.variables
trends <- t(trends)
trends <- cbind(rownames(trends), trends)
rownames(trends) <- NULL
trends <- as_tibble(trends)
colnames(trends) <- c("key", newcolnames)
trends$key <- as.character(trends$key)
# get linear fits
lme_fitL <- as.data.frame(sapply(fitlist_lme4, "[[", 3))
colnames(lme_fitL) <- lme_stat$key
lme_fitL <- t(lme_fitL)
colnames(lme_fitL) <- paste(rep('fitL',(nSub*nbin)), 1:(nSub*nbin), sep="_", collapse = NULL)
lme_fitL <- cbind(rownames(lme_fitL), lme_fitL)
colnames(lme_fitL)[1] <- c("key")
lme_fitL <- as_tibble(lme_fitL)
# get quadratic fits
lme_fitQ <- as.data.frame(sapply(fitlist_lme4, "[[", 4))
colnames(lme_fitQ) <- lme_stat$key
lme_fitQ <- t(lme_fitQ)
colnames(lme_fitQ) <- paste(rep('fitQ',(nSub*nbin)), 1:(nSub*nbin), sep="_", collapse = NULL)
lme_fitQ <- cbind(rownames(lme_fitQ), lme_fitQ)
colnames(lme_fitQ)[1] <- c("key")
lme_fitQ <- as_tibble(lme_fitQ)
# merge
Output_mat <- lme_stat2 %>%
merge(., trends,  by = "key") %>%
merge(., lme_fitL,  by = "key") %>%
merge(., lme_fitQ,  by = "key")
Output_mat <- as_tibble(Output_mat)
Output_mat$Df_Intercept  <- as.character(Output_mat$Df_Intercept)
Output_mat$Df_L  <- as.character(Output_mat$Df_L)
Output_mat$Df_Q  <- as.character(Output_mat$Df_Q)
Output_mat$Chisq_L  <- as.character(Output_mat$Chisq_L)
Output_mat$Chisq_Q  <- as.character(Output_mat$Chisq_Q)
Output_mat$P_L  <- as.character(Output_mat$P_L)
Output_mat$P_Q  <- as.character(Output_mat$P_Q)
write.csv(Output_mat, str_c(filedir, filename, '_R_statistics','.csv'),row.names = FALSE, na="")
# load the relevant libraries
x<-c("tidyverse","car", "nlme", "lme4", "ez", "dplyr", "ggplot2", "knitr","stringr","nortest","gridExtra","png","R.matlab","lmerTest","simpleboot")
lapply(x, function(x) {if (!require(x, character.only=T)) {install.packages(x);require(x)}})
# clear all
rm(list=ls(all=TRUE))
# which dataset?
dataset2use = 'bigDots'; nSub = 80;
dataset2use = 'CD'; nSub = 17;
filedir = str_c('E:/Monash/', dataset2use, '/data/population/')
figDir  = str_c(filedir, 'fig/R/' )
dir.create(figDir, showWarnings = TRUE)
# load useful functions ---------------------------------------------------
wddir   = str_c('C:/Jochem/repositories/2018_Monash/')
setwd(wddir)
source("summarySE.R")
# a few settings defined in Matlab, goes in the filename that will be loaded
CSD = 0
nChanAlpha = 3
# what is the number of bins etc?
nside           = 1;
nbin            = 5;
bintype         = 'equal';
# which sorting?
bin2use         = 'pupil_lp_RT_neg200_200_regress_bl_iti_side';
# load participant level data
filename = str_c('participant_level_side(',nside ,')_bin(', nbin, ')_', bin2use ,
'_equal_CSD(', CSD, ')_','chAlpha(', nChanAlpha, ')_final' )
data_p_level = read_csv(str_c(filedir, filename,'.csv'))
data_p_level$Subject <- factor(data_p_level$Subject)
data_p_level$Side <- factor(data_p_level$Side)
data_p_level$Bin <- factor(data_p_level$Bin,labels=c("1", "2", "3", "4", "5"))
#  ------------------------------------------------------------------------
## check number of trials in each condition
sum_trials <- summarySE(data_p_level, measurevar="nTrial", groupvars=c("Bin","Side"))
sum_trials <- data.frame(sum_trials)
tt <- ttheme_default(colhead=list(fg_params = list(parse=TRUE)))
tbl <- tableGrob(sum_trials, rows=NULL, theme=tt)
png(str_c(figDir,'nTrials', bin2use, '.png'))
grid.arrange(tbl)
dev.off()
#  ------------------------------------------------------------------------
data_p_level$Bin <- as.numeric(data_p_level$Bin) # for polynomial contrasts to be set
data_p_level <- within(data_p_level, polyBin <- poly(Bin,2)) # define orthogonal polynomial
# our model has a random intercept for each subject (repeated measrures analysis)
model.Intercept     <- lme4::lmer(RT ~ 1 +
(1|Subject),
data = data_p_level, na.action = na.omit, REML=FALSE) # baseline model to compare the effect of bin to.
model.bin       <- update(model.Intercept, .~. + polyBin[, 1]) # test linear polynomial
model.binQ      <- update(model.bin, .~. + polyBin[, 2])# test quadratic polynomial
# model.bin       <- update(model.Intercept, .~. + Bin) # test linear polynomial, not orthogonal!!
# model.binQ      <- update(model.bin, .~. + I(Bin^2))# test linear polynomial, not orthogonal!!
anova(model.Intercept, model.bin, model.binQ) #compare likelihood of models
library(broom)
summary(model.binQ)
kable(tidy(model.binQ),digits = 3)
library(MuMIn)
r.squaredGLMM(model.binQ)
# see https://jonlefcheck.net/2013/03/13/r2-for-linear-mixed-effects-models/ for an explanation of marginal and conditional R2
library(piecewiseSEM)
rsquared(list(model.Intercept,model.binQ))
#
# exclude some variables
all.dependent.variables <- data_p_level %>%
dplyr::select(-one_of("Subject"), -one_of("Side"), -one_of("Bin"), -one_of("polyBin"),
-one_of("nTrial"),
-one_of("pupil_bl_lp"), -one_of("pupil_bl_bp")) %>%
names()
fitlist_lme4 <- lapply(all.dependent.variables, function(i) {
eval(parse(text=
paste0('
model.baseline     <- lme4::lmer(', i, ' ~ (1|Subject), data = data_p_level, na.action = na.omit, REML=FALSE) # baseline model to compare the effect of bin to
model.bin          <- update(model.baseline, .~. + polyBin[, 1]) # test model with Bin, linear
model.binQ         <- update(model.bin, .~. + polyBin[, 2]) # test model with Bin, quadratic
stat <- anova(model.baseline, model.bin,model.binQ)
# model.bin <- as(model.bin,"merModLmerTest") # use the lmerTest package to obtain a p-value for the coefficients
trend <- coef(summary(model.binQ))
fit_Y_L <- predict(model.bin)
mat_fitL <- matrix(NA, nrow =1, ncol = (nSub*nbin))
mat_fitL[as.numeric(names(fit_Y_L))] <-  unname(fit_Y_L)
# mat_fitL <- matrix(mat_fitL, nrow = nSub, byrow = FALSE)
fit_Y_Q <- predict(model.binQ)
mat_fitQ <- matrix(NA, nrow =1, ncol = (nSub*nbin))
mat_fitQ[as.numeric(names(fit_Y_Q))] <-  unname(fit_Y_Q)
# mat_fitQ <- matrix(mat_fitQ, nrow = nSub, byrow = FALSE)
list(stat=stat, trend=trend, fitL=mat_fitL, fitQ=mat_fitQ)
')
))
})
# write the results to a csv file
### lme4 stats
lme_stat <- as.data.frame(sapply(fitlist_lme4, "[[", 1))
colnames(lme_stat) <- all.dependent.variables
lme_stat <- t(lme_stat)
lme_stat <- cbind(rownames(lme_stat), lme_stat)
rownames(lme_stat) <- NULL
colnames(lme_stat)[1] <- c("key")
lme_stat <- as_tibble(lme_stat)
lme_stat$key <- as.character(lme_stat$key)
lme_stat2 <- lme_stat[,1]
lme_stat2$Df_Intercept <- sapply(lme_stat$Df, "[[", 1)
lme_stat2$Df_L <- sapply(lme_stat$Df, "[[", 2)
lme_stat2$Df_Q <- sapply(lme_stat$Df, "[[", 3)
lme_stat2$Chisq_L <- sapply(lme_stat$Chisq, "[[", 2)
lme_stat2$Chisq_Q <- sapply(lme_stat$Chisq, "[[", 3)
lme_stat2$P_L <- sapply(lme_stat$`Pr(>Chisq)`, "[[", 2)
lme_stat2$P_Q <- sapply(lme_stat$`Pr(>Chisq)`, "[[", 3)
### lme4 trends
row2get = c(2,3)
col2get = c(1,2,3)
trendlist_colnames <- names(data.frame(fitlist_lme4[[1]]$trend))
trendlist_rownames <- rownames(data.frame(fitlist_lme4[[1]]$trend))
trendlist_rownames <- rownames(data.frame(fitlist_lme4[[1]]$trend))
trendlist_colnames[which(trendlist_colnames=="Estimate")] <- 'Estimate_Trend'
trendlist_colnames[which(trendlist_colnames=="Std..Error")] <- 'SE_Trend'
trendlist_colnames[which(trendlist_colnames=="t.value")] <- 't_Trend'
trendlist_rownames[which(trendlist_rownames=="(Intercept)")] <- 'Intercept'
trendlist_rownames[which(trendlist_rownames=="polyBin[, 1]")] <- 'BinL'
trendlist_rownames[which(trendlist_rownames=="polyBin[, 2]")] <- 'BinQ'
trends <- as.data.frame(sapply(1:length(fitlist_lme4), function(i) as.numeric(fitlist_lme4[[i]]$trend[row2get,col2get])))
newcolnames <- apply(expand.grid(trendlist_rownames[row2get], trendlist_colnames[col2get]), 1, function(x) paste(x[1], x[2], sep="_"))
colnames(trends) <- all.dependent.variables
trends <- t(trends)
trends <- cbind(rownames(trends), trends)
rownames(trends) <- NULL
trends <- as_tibble(trends)
colnames(trends) <- c("key", newcolnames)
trends$key <- as.character(trends$key)
# get linear fits
lme_fitL <- as.data.frame(sapply(fitlist_lme4, "[[", 3))
colnames(lme_fitL) <- lme_stat$key
lme_fitL <- t(lme_fitL)
colnames(lme_fitL) <- paste(rep('fitL',(nSub*nbin)), 1:(nSub*nbin), sep="_", collapse = NULL)
lme_fitL <- cbind(rownames(lme_fitL), lme_fitL)
colnames(lme_fitL)[1] <- c("key")
lme_fitL <- as_tibble(lme_fitL)
# get quadratic fits
lme_fitQ <- as.data.frame(sapply(fitlist_lme4, "[[", 4))
colnames(lme_fitQ) <- lme_stat$key
lme_fitQ <- t(lme_fitQ)
colnames(lme_fitQ) <- paste(rep('fitQ',(nSub*nbin)), 1:(nSub*nbin), sep="_", collapse = NULL)
lme_fitQ <- cbind(rownames(lme_fitQ), lme_fitQ)
colnames(lme_fitQ)[1] <- c("key")
lme_fitQ <- as_tibble(lme_fitQ)
# merge
Output_mat <- lme_stat2 %>%
merge(., trends,  by = "key") %>%
merge(., lme_fitL,  by = "key") %>%
merge(., lme_fitQ,  by = "key")
Output_mat <- as_tibble(Output_mat)
Output_mat$Df_Intercept  <- as.character(Output_mat$Df_Intercept)
Output_mat$Df_L  <- as.character(Output_mat$Df_L)
Output_mat$Df_Q  <- as.character(Output_mat$Df_Q)
Output_mat$Chisq_L  <- as.character(Output_mat$Chisq_L)
Output_mat$Chisq_Q  <- as.character(Output_mat$Chisq_Q)
Output_mat$P_L  <- as.character(Output_mat$P_L)
Output_mat$P_Q  <- as.character(Output_mat$P_Q)
write.csv(Output_mat, str_c(filedir, filename, '_R_statistics','.csv'),row.names = FALSE, na="")
# Now the complete re
